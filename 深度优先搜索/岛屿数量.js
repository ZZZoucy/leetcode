// 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
// 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
// 输入：grid = [
//     ["1","1","0","0","0"],
//     ["1","1","0","0","0"],
//     ["0","0","1","0","0"],
//     ["0","0","0","1","1"]
//   ]
//   输出：3

/**
 * @param {character[][]} grid
 * @return {number}
 */

// 使用深度优先搜索
// 遍历每行每列，出现 1 的时候，先记录下一个岛屿，再进入 dfs 去完全搜索岛屿大小
// dfs 完全搜索岛屿大小的意思就是在出现 1 的地方，遍历该 1 的四个方向，遍历完之后，某一个岛屿的1就已经全置为0了
// 然后继续回去遍历 行列 中出现的 1 ，如此往复，遍历完所有的岛屿，记录下 res（岛屿个数）

var numIslands = function (grid) {
    let res = 0;
    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
            // 在四个方向都遍历之后，再回到这个语句就说明第二个岛屿开始安排了
            if (grid[i][j] === "1") {
                res++;
                dfs(grid, i, j);
            }
        }
    }
    return res;
};

function dfs(grid, i, j) {
    // 递归边界
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === "0") {
        return;
    }
    //标记已访问的1置为0
    grid[i][j] = "0";
    //遍历四个方向，遍历完之后，某一个岛屿的1就已经全置为0了
    for (let d of [
        [0, 1],
        [0, -1],
        [-1, 0],
        [1, 0],
    ]) {
        dfs(grid, i + d[0], j + d[1]);
    }
}
